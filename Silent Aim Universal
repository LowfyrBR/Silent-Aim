local AimbotSettings = {
    SilentAim = true,
    SilentAimHitChance = 100,
    Wallbang = false,
    AimPart = "Torso" -- Head or Torso 
}

local function UpdateAimlockTarget(character)
    if not character then return end
    if AimbotSettings.AimPart == "Torso" then
        Aimlock = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
    elseif AimbotSettings.AimPart == "Torso" then
        Aimlock = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso") or character:FindFirstChild("Torso")
    else
        Aimlock = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
    end
end

-- E sempre que o alvo for atualizado:
UpdateAimlockTarget(ClosestCharacter)

-- Variáveis e hooks para Silent Aim
local Hooks = {
    HookedFunctions = {},
    OldMetaMethods = {},
    MetaMethodHooks = {},
    HookedSignals = {}
}

local HookedFunctions = Hooks.HookedFunctions
local MetaMethodHooks = Hooks.MetaMethodHooks
local OldMetaMethods = Hooks.OldMetaMethods

-- Variáveis auxiliares randomizadas para pequenas variações na mira
local randomised = random(1, 10)
local randomisedVector = Vector3new(random(1, 10), random(1, 10), random(1, 10))

-- Atualiza randomizadas no movimento do mouse
Mouse.Move:Connect(function()
    randomised = random(1, 10)
    randomisedVector = Vector3new(random(1, 10), random(1, 10), random(1, 10))
end)

-- Hook no metamétodo __index para interceptar acessos ao mouse e alterar o comportamento para Silent Aim
MetaMethodHooks.Index = function(...)
    local __Index = OldMetaMethods.__index

    if (Player and Aimlock and ... == Mouse and not checkcaller()) then
        local CallingScript = getfenv(2).script
        if (CallingScript.Name == "CallingScript") then
            return __Index(...)
        end

        local _Mouse, Index = ...
        if (type(Index) == 'string') then
            Index = gsub(sub(Index, 0, 100), "%z.*", "")
        end

        local PassedChance = random(1, 100) < AimbotSettings.SilentAimHitChance

        if (PassedChance and AimbotSettings.SilentAim) then
            -- Verifica se há partes obstruindo o tiro entre câmera e alvo
            local Parts = GetPartsObscuringTarget(CurrentCamera, {CurrentCamera.CFrame.Position, Aimlock.Position}, {LocalPlayer.Character, ClosestCharacter})

            -- Normaliza a primeira letra do Index para maiúscula
            Index = string.gsub(Index, "^%l", upper)

            local Hit = #Parts == 0 or AimbotSettings.Wallbang
            if (not Hit) then
                return __Index(...)
            end

            -- Redireciona o alvo e posição do tiro para o Aimlock
            if (Index == "Target") then
                return Aimlock
            end

            if (Index == "Hit") then
                local hit = __Index(...)
                local pos = Aimlock.Position + randomisedVector / 10
                return CFramenew(pos.X, pos.Y, pos.Z, unpack({hit:components()}, 4))
            end

            if (Index == "X") then
                return Vector.X + randomised / 10
            end

            if (Index == "Y") then
                return Vector.Y + randomised / 10
            end
        end
    end

    return __Index(...)
end

-- Hook no __namecall para interceptar métodos do Workspace relacionados a encontrar partes no raycast
MetaMethodHooks.Namecall = function(...)
    local __Namecall = OldMetaMethods.__namecall
    local self = ...
    local Method = gsub(getnamecallmethod() or "", "^%l", upper)
    local Hooked = HookedFunctions[Method]

    if (Hooked and self == Hooked[1]) then
        return Hooked[3](...)
    end

    return __Namecall(...)
end

-- Hook na função FindPartOnRay para modificar resultado se Silent Aim estiver ativo
HookedFunctions.FindPartOnRay = {Workspace, Workspace.FindPartOnRay, function(...)
    local OldFindPartOnRay = HookedFunctions.FindPartOnRay[4]
    if (AimbotSettings.SilentAim and Player and Aimlock and not checkcaller()) then
        local PassedChance = random(1, 100) < AimbotSettings.SilentAimHitChance
        if (ClosestCharacter and PassedChance) then
            local Parts = GetPartsObscuringTarget(CurrentCamera, {CurrentCamera.CFrame.Position, Aimlock.Position}, {LocalPlayer.Character, ClosestCharacter})
            if (#Parts == 0 or AimbotSettings.Wallbang) then
                return Aimlock, Aimlock.Position + (Vector3new(random(1, 10), random(1, 10), random(1, 10)) / 10), Vector3new(0, 1, 0), Aimlock.Material
            end
        end
    end
    return OldFindPartOnRay(...)
end}

-- Hook na função FindPartOnRayWithIgnoreList para modificar resultado se Silent Aim estiver ativo
HookedFunctions.FindPartOnRayWithIgnoreList = {Workspace, Workspace.FindPartOnRayWithIgnoreList, function(...)
    local OldFindPartOnRayWithIgnoreList = HookedFunctions.FindPartOnRayWithIgnoreList[4]
    if (Player and Aimlock and not checkcaller()) then
        local CallingScript = getcallingscript()
        local PassedChance = random(1, 100) < AimbotSettings.SilentAimHitChance
        if (CallingScript.Name ~= "ControlModule" and ClosestCharacter and PassedChance) then
            local Parts = GetPartsObscuringTarget(CurrentCamera, {CurrentCamera.CFrame.Position, Aimlock.Position}, {LocalPlayer.Character, ClosestCharacter})
            if (#Parts == 0 or AimbotSettings.Wallbang) then
                return Aimlock, Aimlock.Position + (Vector3new(random(1, 10), random(1, 10), random(1, 10)) / 10), Vector3new(0, 1, 0), Aimlock.Material
            end
        end
    end
    return OldFindPartOnRayWithIgnoreList(...)
end}

-- Aplica os hooks nas funções
for Index, Function in pairs(HookedFunctions) do
    Function[4] = hookfunction(Function[2], Function[3])
end

-- Aplica os hooks nos metamétodos
for MMName, MMFunc in pairs(MetaMethodHooks) do
    local MetaMethod = string.format("__%s", string.lower(MMName))
    Hooks.OldMetaMethods[MetaMethod] = hookmetamethod(game, MetaMethod, MMFunc)
end
